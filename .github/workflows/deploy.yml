name: Deploy

on:
  push:
    tags:
      - 'v*'  # Uruchom tylko dla tagów zaczynających się od "v" (np. v0.0.1)
  workflow_dispatch:

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    environment: drobit-production
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # BACKEND
      - name: Build and push Backend
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./apps/server/Dockerfile
          push: true
          tags: |
            ghcr.io/${{ github.repository_owner }}/scale-app-backend:latest
            ghcr.io/${{ github.repository_owner }}/scale-app-backend:${{ github.sha }}
            ghcr.io/${{ github.repository_owner }}/scale-app-backend:${{ github.ref_name }}

      # FRONTEND
      - name: Build and push Frontend
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./apps/web/Dockerfile
          push: true
          tags: |
            ghcr.io/${{ github.repository_owner }}/scale-app-frontend:latest
            ghcr.io/${{ github.repository_owner }}/scale-app-frontend:${{ github.sha }}
            ghcr.io/${{ github.repository_owner }}/scale-app-frontend:${{ github.ref_name }}
          build-args: |
            NEXT_PUBLIC_API_URL=https://${{ vars.BACKEND_DOMAIN }}
            NEXT_PUBLIC_WS_URL=wss://${{ vars.BACKEND_DOMAIN }}

  deploy:
    needs: build-and-push
    environment: drobit-production
    runs-on: ubuntu-latest
    permissions:
      contents: write # WYMAGANE do stworzenia Release
    steps:
      - uses: actions/checkout@v4

      # Instalacja narzędzi
      - name: Install kubectl
        uses: azure/setup-kubectl@v3

      - name: Install Helm
        uses: azure/setup-helm@v4

      # Konfiguracja dostępu do K3s
      - name: Set KUBECONFIG
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBECONFIG }}" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config

      # 1. Image Pull Secret (z zabezpieczeniem przed błędem, jeśli istnieje)
      - name: Create Image Pull Secret
        run: |
          # 1. Najpierw upewnij się, że namespace istnieje!
          kubectl create namespace scale-app --dry-run=client -o yaml | kubectl apply -f -

          # 2. Teraz stwórz/zaktualizuj sekret
          kubectl create secret docker-registry ghcr-secret \
            --docker-server=ghcr.io \
            --docker-username=${{ github.actor }} \
            --docker-password=${{ secrets.GITHUB_TOKEN }} \
            --docker-email=${{ vars.ACME_EMAIL }} \
            -n scale-app \
            --dry-run=client -o yaml | kubectl apply -f -

      # 2. Renderowanie plików (envsubst)
      - name: Render Manifests
        shell: bash
        env:
          # Secrets
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_USER: ${{ secrets.DB_USER }}
          DB_NAME: ${{ secrets.DB_NAME }}
          REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
          MQTT_USERNAME: ${{ secrets.MQTT_USERNAME }}
          MQTT_PASSWORD_HASH: ${{ secrets.MQTT_PASSWORD_HASH }} 
          BETTER_AUTH_SECRET: ${{ secrets.BETTER_AUTH_SECRET }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          GRAFANA_ADMIN_PASSWORD: ${{ secrets.GRAFANA_ADMIN_PASSWORD }}
          # Vars
          ACME_EMAIL: ${{ vars.ACME_EMAIL }}
          FRONTEND_DOMAIN: ${{ vars.FRONTEND_DOMAIN }}
          BACKEND_DOMAIN: ${{ vars.BACKEND_DOMAIN }}
          MONITORING_DOMAIN: ${{ vars.MONITORING_DOMAIN }}
        run: |
          mkdir -p k8s/generated
          
          # Upewnij się, że masz pakiet gettext-base
          # sudo apt-get install -y gettext-base
          
          for file in k8s/01-secrets-template.yaml k8s/02-configs.yaml k8s/apps/ingress.yaml; do
            envsubst < "$file" > "k8s/generated/$(basename "$file")"
          done

      # 3. Aplikowanie zmian K8s
      - name: Apply K8s Manifests
        run: |
          # Namespaces i Configi
          kubectl apply -f k8s/00-namespaces.yaml
          kubectl apply -f k8s/generated/
          kubectl apply -f k8s/infrastructure/
          
          # Podmiana obrazów 
          REPO_OWNER="${{ github.repository_owner }}"
          REPO_OWNER="${REPO_OWNER,,}" 

          # WAŻNE: Podmieniamy na hash commita (github.sha) - to najbezpieczniejsza metoda
          # nawet przy tagach, bo hash jest jednoznaczny.
          sed -i "s|ghcr.io/PLACEHOLDER_USER/scale-app-backend:latest|ghcr.io/$REPO_OWNER/scale-app-backend:${{ github.sha }}|g" k8s/apps/backend.yaml
          sed -i "s|ghcr.io/PLACEHOLDER_USER/scale-app-frontend:latest|ghcr.io/$REPO_OWNER/scale-app-frontend:${{ github.sha }}|g" k8s/apps/frontend.yaml
          
          kubectl apply -f k8s/apps/backend.yaml
          kubectl apply -f k8s/apps/frontend.yaml

      # 4. Monitoring (Helm)
      - name: Deploy Monitoring
        run: |
          helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
          helm repo update
          # --wait sprawi, że workflow poczeka aż monitoring wstanie
          helm upgrade --install monitoring prometheus-community/kube-prometheus-stack \
            -n monitoring \
            -f k8s/monitoring/values.yaml \
            --set grafana.adminPassword=${{ secrets.GRAFANA_ADMIN_PASSWORD }}

      # 5. Create Release (NOWY KROK)
      - name: Create Release
        uses: softprops/action-gh-release@v1
        if: startsWith(github.ref, 'refs/tags/')
        with:
          generate_release_notes: true
          # Opcjonalnie: jeśli chcesz, aby release był oznaczony jako 'prerelease' dla tagów typu v0.0.1-beta
          prerelease: ${{ contains(github.ref, '-') }}